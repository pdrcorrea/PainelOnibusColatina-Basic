<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PontoView • Ônibus</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- Inter -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&display=swap" rel="stylesheet">

  <!-- Material Symbols (Google Fonts) -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,500,0,0" />

  <style>
    :root{
      --ink:#0b1626;

      --topA:#0b2a44;
      --topB:#2c6aa3;
      --topC:#0f3d63;

      --pad: clamp(14px, 1.8vw, 26px);
      --gap: clamp(12px, 1.4vw, 18px);

      /* menos “branco estourado” */
      --panel:#e7edf5;
      --card: rgba(255,255,255,.78);
      --line: rgba(210,222,238,.95);

      --radius: clamp(24px, 2.2vw, 36px);
      --radiusCard: clamp(18px, 1.8vw, 28px);

      --footerH: clamp(54px, 6vh, 78px);

      --ease: cubic-bezier(.2,.8,.2,1);
      --anim: 520ms;

      --dividerGrad: linear-gradient(90deg, rgba(44,106,163,0) 0%, rgba(44,106,163,.9) 18%, rgba(15,61,99,.95) 50%, rgba(44,106,163,.9) 82%, rgba(44,106,163,0) 100%);

      --pillDark:#3a4656;
      --pillDark2:#2f3845;

      --stageGap: 12px;

      /* cor padrão PontoView para linhas sem cor na API */
      --pvBlue:#0f3d63;
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:#fff;
      overflow:hidden;
    }

    .pvPage{ width:100vw; height:100vh; background:#fff; }
    .pvShell{
      width:100%;
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
      background:#fff;
    }

    /* ===== HEADER ===== */
    .pvHeader{
      position:relative;
      background: linear-gradient(180deg, var(--topB) 0%, var(--topC) 42%, var(--topA) 100%);
      color:#fff;
      padding: clamp(14px, 1.8vw, 22px) var(--pad);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
      flex:0 0 auto;
      min-width:0;
      border-bottom: 1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 -1px 0 rgba(255,255,255,.18);
    }
    .pvHeader::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 120px at 50% 0%, rgba(255,255,255,.22), rgba(255,255,255,0) 65%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,0) 42%);
      opacity:.95;
    }
    .pvHeaderLeft, .pvHeaderRight{ position:relative; z-index:1; }
    .pvHeaderLeft{
      display:flex;
      align-items:center;
      gap: clamp(12px, 1.5vw, 18px);
      min-width:0;
      flex:1 1 auto;
    }

    .pvIconBadge{
      width: clamp(44px, 4.2vw, 64px);
      height: clamp(44px, 4.2vw, 64px);
      border-radius: 18px;
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.24);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.20),
        0 14px 28px rgba(0,0,0,.14);
      backdrop-filter: blur(10px);
      display:grid;
      place-items:center;
      flex:0 0 auto;
      color:#fff;
    }
    .pvIconBadge .material-symbols-outlined{
      font-size: 34px;
      line-height: 1;
      color:#fff;
      font-variation-settings:
        'FILL' 0,
        'wght' 600,
        'GRAD' 0,
        'opsz' 24;
      opacity:.98;
    }

    .pvTitles{ display:flex; flex-direction:column; gap:6px; min-width:0; }
    .pvTitle{
      margin:0;
      font-size: clamp(18px, 2.1vw, 34px);
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      line-height:1.02;
    }
    .pvSubtitle{
      font-size: clamp(11px, 1.0vw, 15px);
      font-weight:900;
      letter-spacing:.14em;
      text-transform:uppercase;
      opacity:.92;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .pvHeaderRight{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      min-width:max-content;
    }
    .pvClock{
      user-select:none;
      font-size: clamp(12px, 1.1vw, 16px);
      font-weight: 900;
      letter-spacing:.10em;
      text-transform: uppercase;
      color:#fff;
      padding: clamp(10px, 1.1vw, 14px) clamp(14px, 1.5vw, 22px);
      border-radius: 999px;
      background: rgba(255,255,255,.16);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.18),
        0 12px 26px rgba(0,0,0,.14);
      backdrop-filter: blur(10px);
      white-space:nowrap;
    }

    /* ===== SUBBAR ===== */
    .pvSubbar{
      flex:0 0 auto;
      padding: 10px var(--pad);
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      border-bottom: 1px solid rgba(210,222,238,.9);
    }
    .pvSubLeft{
      min-width:0;
      font-size: 11px;
      font-weight: 900;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:#344257;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .pvPageLabel{
      font-size: 11px;
      font-weight: 900;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:#344257;
      opacity:.95;
      white-space:nowrap;
    }

    /* ===== CONTENT ===== */
    .pvContent{
      flex:1 1 auto;
      min-height:0;
      padding: var(--pad);
      background:#fff;
      overflow:hidden;
    }
    .pvCard{
      height:100%;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(231,237,245,1), rgba(223,232,244,1));
      padding: clamp(12px, 1.4vw, 18px);
      min-height:0;
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.45);
    }

    /* ===== STAGE / PÁGINAS ===== */
    .busWrap{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
      gap: 12px;
    }
    .warn{
      display:none;
      padding: 12px 14px;
      border-radius: 14px;
      background: #fff7ed;
      border: 1px dashed #fdba74;
      color: #7c2d12;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .10em;
      text-transform: uppercase;
    }
    .stage{
      position:relative;
      flex: 1;
      min-height:0;
      overflow:hidden;
      background: transparent;
    }
    .page{
      position:absolute;
      inset: 0;
      display:grid;
      gap: var(--stageGap);
      align-content:start;
      opacity:0;
      transform: translateX(18px);
      pointer-events:none;
    }
    .page.active{
      opacity:1;
      transform: translateX(0);
      pointer-events:auto;
      transition: opacity var(--anim) var(--ease), transform var(--anim) var(--ease);
    }
    .page.exit{
      opacity:0;
      transform: translateX(-18px);
      transition: opacity var(--anim) var(--ease), transform var(--anim) var(--ease);
    }

    /* ===== CARD (landscape) ===== */
    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radiusCard);
      padding: clamp(12px, 1.25vw, 15px);
      display:grid;
      grid-template-columns: 96px minmax(0, 1fr) 188px;
      align-items:center;
      gap: clamp(10px, 1.3vw, 16px);
      min-width:0;
      box-shadow: 0 12px 26px rgba(2,10,23,.10);
      backdrop-filter: blur(7px);
      position:relative;
      overflow:hidden;
      min-height: 82px;
    }

    .stripe{
      position:absolute;
      inset:0 auto 0 0;
      width: 10px;
      border-radius: 999px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.35);
    }

    .lineCol{
      display:flex;
      flex-direction:column;
      gap: 2px;
      align-items:flex-start;
      padding-left: 10px;
      min-width:0;
    }
    .lineNum{
      font-size: clamp(26px, 2.4vw, 38px);
      font-weight: 900;
      letter-spacing: .02em;
      line-height: 1;
      color: var(--ink);
      font-variant-numeric: tabular-nums;
    }

    .destCol{ min-width:0; }

    /* ===== DESTINO (SEM FADE) + MARQUEE SUAVE ===== */
    .destName{
      position: relative;
      min-width: 0;
      overflow:hidden;
      white-space:nowrap;
      font-size: clamp(18px, 1.95vw, 30px);
      font-weight: 900;
      letter-spacing: .02em;
      text-transform: uppercase;
      color: var(--ink);
      padding-right: 10px;

      /* removido fade (mask) */
      mask-image: none;
      -webkit-mask-image: none;
    }
    .destText{
      display:inline-block;
      white-space:nowrap;
      will-change: transform;
    }
    .destName.is-marquee .destText{
      animation: pvMarquee var(--marqDur, 10s) linear infinite;
    }
    @keyframes pvMarquee{
      0%{ transform: translateX(0); }
      10%{ transform: translateX(0); }
      90%{ transform: translateX(calc(-1 * var(--marqMove, 0px))); }
      100%{ transform: translateX(calc(-1 * var(--marqMove, 0px))); }
    }

    /* ===== HORÁRIOS (discreto) ===== */
    .timesCol{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      width: 100%;
    }
    .timeRow{
      width: 100%;
      max-width: 168px;
      display:flex;
      align-items: stretch;
      gap: 8px;
      justify-content:flex-end;
    }

    .next{
      flex: 1 1 auto;
      text-align:left;
      padding: 8px 10px;
      border-radius: 14px;
      background: rgba(15,61,99,.08);
      border: 1px solid rgba(15,61,99,.16);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      height: 100%;
      box-shadow: 0 6px 14px rgba(0,0,0,.04);
    }
    .next .when{
      font-size: clamp(18px, 1.8vw, 26px);
      font-weight: 900;
      letter-spacing: .04em;
      color: rgba(11,22,38,.95);
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }
    .next .label{
      margin: 4px 0 0 0;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: rgba(52,66,87,.92);
      white-space:nowrap;
    }
    .next .statusDot{
      width:10px;
      height:10px;
      border-radius:999px;
      background: rgba(59,130,246,.92);
      box-shadow: 0 0 0 3px rgba(59,130,246,.16);
      flex:0 0 auto;
    }
    .next.is-soon{
      background: rgba(31,167,101,.10);
      border-color: rgba(31,167,101,.22);
    }
    .next.is-soon .statusDot{
      background: rgba(31,167,101,.95);
      box-shadow: 0 0 0 3px rgba(31,167,101,.16);
    }

    .nextSide{
      flex: 0 0 auto;
      width: 72px;
      border-radius: 14px;
      border: 1px solid rgba(15,61,99,.14);
      background: rgba(255,255,255,.55);
      padding: 7px 7px;
      display:flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 6px 14px rgba(0,0,0,.04);
    }
    .nextSideItem{
      width: 100%;
      text-align:center;
      font-size: 9px;
      font-weight: 900;
      letter-spacing: .10em;
      padding: 5px 6px;
      border-radius: 999px;
      border: 1px solid rgba(210,222,238,.95);
      background: rgba(15,61,99,.06);
      color: rgba(11,22,38,.92);
      white-space: nowrap;
      opacity: .98;
    }

    .empty{
      padding: 22px 18px;
      border-radius: 16px;
      background: rgba(255,255,255,.78);
      border: 1px solid var(--line);
      color: #344257;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .14em;
      text-transform: uppercase;
      text-align:center;
      box-shadow: 0 12px 26px rgba(2,10,23,.10);
      backdrop-filter: blur(7px);
    }

    /* ===== PROGRESS (virada de página) ===== */
    .progressWrap{
      flex:0 0 auto;
      padding: 0 var(--pad);
      background:#fff;
    }
    .divider{
      height: 4px;
      border-radius: 999px;
      background: var(--dividerGrad);
      position: relative;
      overflow: hidden;
    }
    #barFill{
      position:absolute;
      inset:0;
      width:0%;
      background: linear-gradient(90deg, rgba(255,255,255,.16), rgba(255,255,255,.38));
      mix-blend-mode: screen;
      border-radius: 999px;
      transition: width 120ms linear;
      transform-origin:left center;
    }

    /* ===== FOOTER (legendas com marquee, logo fixa à direita) ===== */
    .pvFooter{
      flex:0 0 auto;
      height: var(--footerH);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px var(--pad);
      background:#fff;
      gap: 12px;
      min-width:0;
    }

    .brandsViewport{
      flex: 1 1 auto;
      min-width:0;
      overflow:hidden;
      position:relative;
      padding-right: 10px;
    }

    .brandsTrack{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      white-space:nowrap;
      will-change: transform;
    }

    .brandPill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 9px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, var(--pillDark) 0%, var(--pillDark2) 100%);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-weight: 900;
      letter-spacing:.10em;
      text-transform: uppercase;
      font-size: 10px;
      box-shadow: 0 10px 18px rgba(0,0,0,.14);
      max-width: 100%;
    }
    .brandDot{
      width:10px;height:10px;border-radius:999px;
      background: var(--c, #2c6aa3);
      box-shadow: 0 0 0 3px rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .brandTxt{
      max-width: 44vw;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .pvFooterRight{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      flex:0 0 auto;
    }
    .pvLogo{
      height: clamp(16px, 2.3vh, 22px);
      width:auto;
      display:block;
      opacity:.92;
    }

    /* animação do marquee do rodapé */
    .brandsViewport.is-marquee .brandsTrack{
      animation: brandsMarquee var(--brandsDur, 18s) linear infinite;
    }
    @keyframes brandsMarquee{
      0%   { transform: translateX(0); }
      10%  { transform: translateX(0); }
      90%  { transform: translateX(calc(-1 * var(--brandsMove, 0px))); }
      100% { transform: translateX(calc(-1 * var(--brandsMove, 0px))); }
    }

    /* ===== PORTRAIT: destino embaixo do número da linha ===== */
    @media (orientation: portrait){
      .pvFooter{ height: clamp(62px, 8vh, 96px); }

      .card{
        grid-template-columns: 120px 1fr;
        grid-template-rows: auto auto;
        grid-template-areas:
          "line times"
          "dest dest";
        align-items:start;
        row-gap: 10px;
        min-height: 96px;
      }
      .lineCol{ grid-area: line; }
      .timesCol{ grid-area: times; }
      .destCol{ grid-area: dest; }

      .destName{
        font-size: clamp(18px, 2.35vw, 30px);
      }
      .timeRow{ max-width: 172px; }
      .nextSide{ width: 70px; }
    }

    @media (max-width: 640px){
      .timeRow{ max-width: 160px; }
      .nextSide{ width: 66px; }
    }
  </style>
</head>

<body>
  <div class="pvPage">
    <div class="pvShell" id="pvPanel"
      data-title="HORÁRIOS DE SAÍDA"
      data-subleft="Próximas saídas (2h)">

      <header class="pvHeader">
        <div class="pvHeaderLeft">
          <div class="pvIconBadge" aria-hidden="true">
            <span class="material-symbols-outlined">directions_bus</span>
          </div>

          <div class="pvTitles">
            <h1 class="pvTitle" id="pvTitle"></h1>
            <div class="pvSubtitle" id="pvSubtitle"></div>
          </div>
        </div>

        <div class="pvHeaderRight">
          <div class="pvClock" id="pvClock">--:--</div>
        </div>
      </header>

      <div class="pvSubbar">
        <div class="pvSubLeft" id="pvSubLeft"></div>
        <div class="pvSubRight">
          <span class="pvPageLabel" id="pageLabel">PÁGINA 1/1</span>
        </div>
      </div>

      <main class="pvContent">
        <section class="pvCard">
          <div class="busWrap">
            <div class="warn" id="warn"></div>
            <div class="stage" id="stage"></div>
          </div>
        </section>
      </main>

      <div class="progressWrap" aria-hidden="true">
        <div class="divider"><div id="barFill"></div></div>
      </div>

      <footer class="pvFooter">
        <!-- Legenda com marquee (logo fica fixa à direita) -->
        <div class="brandsViewport" id="brandsViewport">
          <div class="brandsTrack" id="brandsTrack"></div>
        </div>

        <div class="pvFooterRight">
          <img class="pvLogo" src="./assets/logo-pontoview.png" alt="PontoView" />
        </div>
      </footer>
    </div>
  </div>

  <!-- KEY vem do config.js geral: window.PONTOVIEW_GMAPS_KEY -->
  <script src="config.js"></script>

  <script>
    /*******************************************************************
     * INIT
     *******************************************************************/
    const panel = document.getElementById("pvPanel");
    const titleEl = document.getElementById("pvTitle");
    const subtitleEl = document.getElementById("pvSubtitle");
    const subLeftEl = document.getElementById("pvSubLeft");

    const brandsViewport = document.getElementById("brandsViewport");
    const brandsTrack = document.getElementById("brandsTrack");

    titleEl.textContent = panel.dataset.title || "";
    subLeftEl.textContent = panel.dataset.subleft || "";

    function pad2(n){ return String(n).padStart(2,"0"); }
    function hhmm(d=new Date()){ return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }
    function tickClock(){ document.getElementById("pvClock").textContent = hhmm(); }
    tickClock();
    const msToNextSecond = 1000 - new Date().getMilliseconds();
    setTimeout(() => { tickClock(); setInterval(tickClock, 1000); }, msToNextSecond);

    /*******************************************************************
     * CONFIG
     *******************************************************************/
    const DEFAULT_STATION_FALLBACK = "Centro da Cidade";

    function getQuery(){
      const q = new URLSearchParams(location.search);
      const station = (q.get("station") || "").trim();
      return { station: station || null };
    }
    const Q = getQuery();

    const PV_CONFIG = {
      STATION_QUERY: Q.station || "Av. Ângelo Giuberti, 291 - Esplanada, Colatina - ES, 29702-060",
      TIME_WINDOW_HOURS: 2,
      SWEEP_POINTS: 12,
      SWEEP_RADIUS_M: 1200,
      REFRESH_EVERY_MS: 30 * 60 * 1000,
      PAST_TOLERANCE_MS: 20_000,
      CLUSTER_GAP_MIN: 2,

      /* footer marquee */
      FOOTER_MARQUEE_PX_PER_SEC: 55,
      FOOTER_MARQUEE_MIN_SEC: 12,
      FOOTER_MARQUEE_MAX_SEC: 26
    };

    const GOOGLE_MAPS_API_KEY = (window.PONTOVIEW_GMAPS_KEY || "").trim() || "COLE_SUA_API_KEY_AQUI";

    const warnEl = document.getElementById("warn");
    const stageEl = document.getElementById("stage");
    const pageLabelEl = document.getElementById("pageLabel");
    const barFillEl = document.getElementById("barFill");

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }
    function fmtHHMM(ms){
      if (!Number.isFinite(ms)) return "--:--";
      const d = new Date(ms);
      return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    }
    function diffMin(aMs, bMs){ return Math.round(Math.abs(aMs - bMs) / 60000); }
    function setStatus(text){ subLeftEl.textContent = text; }

    function clusterTimes(timesMs){
      const t = (timesMs || []).slice().sort((a,b)=>a-b);
      if (!t.length) return [];
      const clusters = [];
      let cur = [t[0]];
      for (let i=1;i<t.length;i++){
        if (diffMin(t[i], t[i-1]) <= PV_CONFIG.CLUSTER_GAP_MIN) cur.push(t[i]);
        else { clusters.push(cur); cur=[t[i]]; }
      }
      clusters.push(cur);
      return clusters.map(c => c.length === 1 ? fmtHHMM(c[0]) : `${fmtHHMM(c[0])}–${fmtHHMM(c[c.length-1])}`);
    }

    /* ====== MARQUEE DESTINO (apenas se overflow) ====== */
    function applyDestMarquee(root = document){
      const nodes = root.querySelectorAll(".destName");
      nodes.forEach(n => {
        n.classList.remove("is-marquee");
        n.style.removeProperty("--marqMove");
        n.style.removeProperty("--marqDur");

        const t = n.querySelector(".destText");
        if (!t) return;

        const over = t.scrollWidth - n.clientWidth;
        if (over > 18){
          n.classList.add("is-marquee");
          n.style.setProperty("--marqMove", `${over}px`);
          const pxPerSec = 40;
          const seconds = Math.max(8, Math.min(18, over / pxPerSec + 6));
          n.style.setProperty("--marqDur", `${seconds}s`);
        }
      });
    }

    /* ====== RODAPÉ: renderiza todas as empresas/operadoras e aplica marquee se não couber ====== */
    function applyFooterMarquee(){
      brandsViewport.classList.remove("is-marquee");
      brandsViewport.style.removeProperty("--brandsMove");
      brandsViewport.style.removeProperty("--brandsDur");

      // se não tem nada, sai
      if (!brandsTrack.children.length) return;

      // mede overflow
      const over = brandsTrack.scrollWidth - brandsViewport.clientWidth;
      if (over > 10){
        brandsViewport.classList.add("is-marquee");
        brandsViewport.style.setProperty("--brandsMove", `${over}px`);

        const pxPerSec = PV_CONFIG.FOOTER_MARQUEE_PX_PER_SEC;
        const seconds = Math.max(
          PV_CONFIG.FOOTER_MARQUEE_MIN_SEC,
          Math.min(PV_CONFIG.FOOTER_MARQUEE_MAX_SEC, over / pxPerSec + 8)
        );
        brandsViewport.style.setProperty("--brandsDur", `${seconds}s`);
      }
    }

    function renderLegendFromCards(cards){
      // Quero “todas as empresas que operam as linhas presentes”.
      // Se a API não devolver agency, agrupamos por "LINHA X" para não colapsar.
      const map = new Map(); // name -> {color, count}

      (cards || []).forEach(c => {
        const name = (c.agency || "").trim();
        if (!name) return;

        const color = (c.lineColor || "").trim() || getComputedStyle(document.documentElement).getPropertyValue("--pvBlue").trim() || "#0f3d63";

        const cur = map.get(name) || { color, count: 0 };
        cur.count += 1;
        // mantém primeira cor que aparecer
        if (!cur.color && color) cur.color = color;
        map.set(name, cur);
      });

      const entries = Array.from(map.entries())
        .sort((a,b)=> (b[1].count - a[1].count) || a[0].localeCompare(b[0]));

      brandsTrack.innerHTML = "";
      if (!entries.length){
        brandsTrack.innerHTML = "";
        applyFooterMarquee();
        return;
      }

      entries.forEach(([name, info]) => {
        const pill = document.createElement("div");
        pill.className = "brandPill";
        pill.style.setProperty("--c", info.color || "#0f3d63");
        pill.title = name;
        pill.innerHTML = `<span class="brandDot"></span><span class="brandTxt">${escapeHtml(name)}</span>`;
        brandsTrack.appendChild(pill);
      });

      // aplica marquee caso não caiba
      requestAnimationFrame(() => requestAnimationFrame(applyFooterMarquee));
    }

    let currentCards = [];
    let pages = [];
    let pageIndex = 0;

    let pageTimer = null;
    let progressTimer = null;
    let pageStart = 0;

    const PAGE_DURATION_MS = 12000;
    const PAGE_PROGRESS_TICK_MS = 120;

    function clearTimers(){
      if (pageTimer) clearTimeout(pageTimer);
      if (progressTimer) clearInterval(progressTimer);
      pageTimer = null;
      progressTimer = null;
    }
    function setPagerLabel(){
      const total = Math.max(1, pages.length);
      pageLabelEl.textContent = `PÁGINA ${Math.min(pageIndex+1, total)}/${total}`;
    }
    function setProgress(p){
      const pct = Math.max(0, Math.min(100, p));
      barFillEl.style.width = pct + "%";
    }

    function buildCardEl(card){
      const el = document.createElement("div");
      el.className = "card";

      const stripeColor = (card.lineColor || "").trim() || "#0f3d63"; // fallback azul PontoView
      const nextMs = card.times[0];
      const next = fmtHHMM(nextMs);
      const rest = card.times.slice(1);

      const nextTimes = clusterTimes(rest);
      const hasNext = nextTimes.length > 0;

      const portrait = window.matchMedia("(orientation: portrait)").matches;
      const MAX_NEXT = portrait ? 2 : 3;
      const show = nextTimes.slice(0, MAX_NEXT);

      const mins = Math.round((nextMs - Date.now()) / 60000);
      const isSoon = Number.isFinite(mins) && mins >= 0 && mins <= 10;

      const nextSideHtml = hasNext
        ? `<div class="nextSide" aria-label="Próximos horários">
            ${show.map(t => `<div class="nextSideItem">${escapeHtml(t)}</div>`).join("")}
           </div>`
        : ``;

      el.innerHTML = `
        <div class="lineCol">
          <div class="lineNum">${escapeHtml(card.line)}</div>
        </div>

        <div class="destCol">
          <div class="destName"><span class="destText">${escapeHtml(card.destination)}</span></div>
        </div>

        <div class="timesCol">
          <div class="timeRow">
            <div class="next ${isSoon ? "is-soon" : ""}">
              <div>
                <div class="when">${next}</div>
                <div class="label">${isSoon ? "SAINDO EM ATÉ 10 MIN" : "PRÓXIMA SAÍDA"}</div>
              </div>
              <span class="statusDot" aria-hidden="true"></span>
            </div>
            ${nextSideHtml}
          </div>
        </div>
      `;

      const stripe = document.createElement("div");
      stripe.className = "stripe";
      stripe.style.background = stripeColor;
      el.prepend(stripe);

      return el;
    }

    async function computePerPage(cards){
      stageEl.innerHTML = "";
      const sample = buildCardEl(cards[0]);
      stageEl.appendChild(sample);
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

      const available = Math.max(0, stageEl.clientHeight);
      const cardH = sample.getBoundingClientRect().height || 92;
      const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--stageGap")) || 12;

      stageEl.innerHTML = "";

      let perPage = Math.floor((available + gap) / (cardH + gap));
      perPage = Math.max(1, Math.min(20, perPage));

      if (perPage === 1 && available > (cardH * 2.2)) perPage = 2;
      if (perPage === 2 && available > (cardH * 3.2)) perPage = 3;

      return Math.max(2, perPage);
    }

    async function paginateCards(cards){
      stageEl.innerHTML = "";
      pages = [];
      pageIndex = 0;

      // legenda do rodapé com marquee se necessário
      renderLegendFromCards(cards);

      if (!cards.length){
        const p = document.createElement("div");
        p.className = "page active";
        p.innerHTML = `<div class="empty">Nenhuma saída encontrada nas próximas ${PV_CONFIG.TIME_WINDOW_HOURS} horas.</div>`;
        stageEl.appendChild(p);
        pages = [p];
        setPagerLabel();
        setProgress(100);
        return;
      }

      const perPage = await computePerPage(cards);

      for (let i=0; i<cards.length; i += perPage){
        const chunk = cards.slice(i, i+perPage);
        const page = document.createElement("div");
        page.className = "page";
        for (const c of chunk) page.appendChild(buildCardEl(c));
        stageEl.appendChild(page);
        pages.push(page);
      }

      pages[0].classList.add("active");
      setPagerLabel();
      startPaging();

      requestAnimationFrame(() => requestAnimationFrame(() => applyDestMarquee(pages[0])));
    }

    function showPage(nextIndex){
      if (!pages.length) return;
      const from = pages[pageIndex];
      const to = pages[nextIndex];
      if (from === to) return;

      from.classList.remove("active");
      from.classList.add("exit");

      to.classList.remove("exit");
      void to.offsetWidth;
      to.classList.add("active");

      setTimeout(() => from.classList.remove("exit"), 560);

      pageIndex = nextIndex;
      setPagerLabel();
      setProgress(0);

      requestAnimationFrame(() => requestAnimationFrame(() => applyDestMarquee(to)));
    }

    function startPaging(){
      clearTimers();
      if (pages.length <= 1){ setProgress(100); return; }

      pageStart = Date.now();
      setProgress(0);

      progressTimer = setInterval(() => {
        const elapsed = Date.now() - pageStart;
        setProgress((elapsed / PAGE_DURATION_MS) * 100);
      }, PAGE_PROGRESS_TICK_MS);

      pageTimer = setTimeout(() => {
        const next = (pageIndex + 1) % pages.length;
        showPage(next);
        startPaging();
      }, PAGE_DURATION_MS);
    }

    /*******************************************************************
     * GOOGLE MAPS
     *******************************************************************/
    function loadGoogleMaps(){
      return new Promise((resolve, reject) => {
        if (window.google?.maps) return resolve();

        const key = (GOOGLE_MAPS_API_KEY || "").trim();
        if (!key || key === "COLE_SUA_API_KEY_AQUI"){
          warnEl.style.display = "block";
          warnEl.textContent = "INSIRA SUA GOOGLE MAPS API KEY NO config.js (window.PONTOVIEW_GMAPS_KEY).";
          return reject(new Error("Missing API key"));
        }

        const script = document.createElement("script");
        script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}`;
        script.async = true;
        script.defer = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error("Falha ao carregar Google Maps JS API"));
        document.head.appendChild(script);
      });
    }

    function geocodeStation(query){
      return new Promise((resolve, reject) => {
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({ address: query }, (results, status) => {
          if (status === "OK" && results && results[0]) resolve(results[0]);
          else reject(new Error("Geocoding falhou: " + status));
        });
      });
    }

    function buildTitleFromGeocode(geo){
      const ac = geo?.address_components || [];
      const pickType = (type) => {
        const found = ac.find(c => (c.types || []).includes(type));
        return found ? (found.long_name || found.short_name || "") : "";
      };

      const neighborhood =
        pickType("neighborhood") || pickType("sublocality_level_1") || pickType("sublocality") || "";

      const city = pickType("locality") || pickType("administrative_area_level_2") || "";
      const state = (ac.find(c => (c.types || []).includes("administrative_area_level_1"))?.short_name) || "";

      if (!neighborhood && city) return `Centro, ${city}`;
      if (neighborhood && city && state) return `${neighborhood}, ${city} - ${state}`;
      if (neighborhood && city) return `${neighborhood}, ${city}`;
      if (city && state) return `${city} - ${state}`;
      if (city) return city;

      return DEFAULT_STATION_FALLBACK;
    }

    function toRad(deg){ return deg * Math.PI / 180; }
    function toDeg(rad){ return rad * 180 / Math.PI; }
    function destinationPoint(lat, lng, bearingDeg, distanceM){
      const R = 6371000;
      const brng = toRad(bearingDeg);
      const dDivR = distanceM / R;
      const lat1 = toRad(lat);
      const lon1 = toRad(lng);

      const lat2 = Math.asin(
        Math.sin(lat1)*Math.cos(dDivR) +
        Math.cos(lat1)*Math.sin(dDivR)*Math.cos(brng)
      );
      const lon2 = lon1 + Math.atan2(
        Math.sin(brng)*Math.sin(dDivR)*Math.cos(lat1),
        Math.cos(dDivR) - Math.sin(lat1)*Math.sin(lat2)
      );

      return { lat: toDeg(lat2), lng: toDeg(lon2) };
    }

    function buildSweepDestinations(stationLatLng){
      const points = [];
      for (let i=0;i<PV_CONFIG.SWEEP_POINTS;i++){
        const bearing = i * (360 / PV_CONFIG.SWEEP_POINTS);
        points.push(destinationPoint(stationLatLng.lat, stationLatLng.lng, bearing, PV_CONFIG.SWEEP_RADIUS_M));
      }
      return points;
    }

    function toMillis(v){
      if (!v) return null;
      if (v instanceof Date) return v.getTime();
      if (typeof v === "number"){
        if (v > 1e12) return v;
        if (v > 1e9)  return v*1000;
      }
      if (typeof v === "object" && v.value) return toMillis(v.value);
      return null;
    }

    function extractTripsFromDirectionsResult(result){
      const trips = [];
      if (!result?.routes?.length) return trips;

      for (const route of result.routes){
        const leg = route.legs?.[0];
        if (!leg?.steps?.length) continue;

        for (const step of leg.steps){
          if (step.travel_mode !== "TRANSIT" || !step.transit) continue;

          const td = step.transit;

          const lineShort = td.line?.short_name || td.line?.name || "—";
          const headsign = td.headsign || td.line?.name || td.arrival_stop?.name || "Destino";

          const depMs = toMillis(td.departure_time) || toMillis(td.departure_time?.value);
          if (!depMs) continue;

          const agencyFromApi =
            td.line?.agencies?.[0]?.name ||
            td.line?.agencies?.[0]?.short_name ||
            "";

          // “empresas que operam as linhas”: se não vier, vira um rótulo estável por linha (não inventa empresa)
          const agencyLabel = agencyFromApi.trim()
            ? agencyFromApi.trim()
            : `LINHA ${String(lineShort).trim() || "—"}`;

          // cor da linha: se a API não informar, mantém azul PontoView
          let lineColor = (td.line?.color || "").trim();
          if (!lineColor) lineColor = "#0f3d63";

          trips.push({
            line: String(lineShort),
            destination: String(headsign),
            timeMs: depMs,
            agency: agencyLabel,
            lineColor,
            key: `${String(lineShort)}|${String(headsign)}|${depMs}|${agencyLabel}|${String(lineColor||"")}`
          });
        }
      }
      return trips;
    }

    function aggregateTrips(allTrips){
      const uniqMap = new Map();
      for (const t of allTrips) uniqMap.set(t.key, t);
      const uniq = Array.from(uniqMap.values());

      const now = Date.now();
      const end = now + PV_CONFIG.TIME_WINDOW_HOURS * 60 * 60 * 1000;

      const groups = new Map();
      for (const t of uniq){
        if (t.timeMs < now - PV_CONFIG.PAST_TOLERANCE_MS) continue;
        if (t.timeMs > end) continue;

        const gKey = `${t.line}||${t.destination}||${t.agency||""}||${t.lineColor||""}`;
        if (!groups.has(gKey)){
          groups.set(gKey, {
            line: t.line,
            destination: t.destination,
            times: [],
            agency: t.agency || "",
            lineColor: t.lineColor || ""
          });
        }
        groups.get(gKey).times.push(t.timeMs);
      }

      const cards = [];
      for (const g of groups.values()){
        g.times.sort((a,b)=>a-b);
        if (!g.times.length) continue;

        cards.push({
          line: g.line,
          destination: g.destination,
          times: g.times,
          nextTime: g.times[0],
          agency: g.agency,
          lineColor: g.lineColor
        });
      }

      cards.sort((a,b)=>a.nextTime - b.nextTime);
      return cards;
    }

    let directionsService = null;
    let refreshTimer = null;
    let STATION_LATLNG = null;

    function requestDirectionsTo(dest){
      return new Promise((resolve) => {
        const req = {
          origin: STATION_LATLNG,
          destination: dest,
          travelMode: google.maps.TravelMode.TRANSIT,
          provideRouteAlternatives: true,
          transitOptions: { departureTime: new Date() }
        };

        directionsService.route(req, (result, status) => {
          if (status === "OK" && result) resolve({ ok:true, result });
          else resolve({ ok:false, status });
        });
      });
    }

    async function refreshData(){
      setStatus("Buscando linhas (varredura 360º)…");
      if (!directionsService) directionsService = new google.maps.DirectionsService();

      const destinations = buildSweepDestinations(STATION_LATLNG);
      const responses = await Promise.all(destinations.map(d => requestDirectionsTo(d)));

      const allTrips = [];
      let okCount = 0;

      for (const r of responses){
        if (r.ok){
          okCount++;
          allTrips.push(...extractTripsFromDirectionsResult(r.result));
        }
      }

      const cards = aggregateTrips(allTrips);
      currentCards = cards;
      await paginateCards(cards);

      if (!okCount) setStatus("Sem resposta da API (verifique a KEY e restrições).");
      else setStatus(`Próximas saídas (${PV_CONFIG.TIME_WINDOW_HOURS}h) • Linhas: ${cards.length}`);
    }

    function scheduleRefresh(){
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(refreshData, PV_CONFIG.REFRESH_EVERY_MS);
    }

    (async function boot(){
      try{
        setStatus("Carregando Google Maps…");
        await loadGoogleMaps();
        warnEl.style.display = "none";

        setStatus("Localizando ponto…");
        const geo = await geocodeStation(PV_CONFIG.STATION_QUERY);

        STATION_LATLNG = {
          lat: geo.geometry.location.lat(),
          lng: geo.geometry.location.lng()
        };

        const locTitle = buildTitleFromGeocode(geo);
        subtitleEl.textContent = String(locTitle || DEFAULT_STATION_FALLBACK).toUpperCase();

        setStatus("Atualizando linhas…");
        await refreshData();
        scheduleRefresh();

        window.addEventListener("resize", async () => {
          await paginateCards(currentCards || []);
          requestAnimationFrame(() => requestAnimationFrame(applyFooterMarquee));
        });
      }catch(err){
        console.warn(err);
        warnEl.style.display = "block";
        warnEl.textContent = "ERRO AO INICIAR: " + (err?.message || String(err));
        subtitleEl.textContent = DEFAULT_STATION_FALLBACK.toUpperCase();
        setStatus("Aguardando configuração…");
      }
    })();
  </script>
</body>
</html>
